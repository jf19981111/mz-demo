# 导航守卫

> 在路由跳转的时候 做一些事情，然后判断是否跳转

- 全局前置守卫 beforeEach

    router.beforeEach((to,from,next) => {})

    to -> 将要去的路由对象
    from -> 当前的路由对象
    next -> 是否允许 如果不使用 next 或者使用 next(false) 都会让路由无法跳转

- 全局的后置钩子 afterEach

    router.beforeEach((to,from) => {})

- 路由独享的守卫

> 在路由的规则中定义 beforeEach 选项

- 组件内的守卫 (通过组件的选项配置的)

    - beforeRouteEnter
    - beforeRouteUpdate

        动态路由参数页面
        当 url 地址直接这种情况的时候 /film/123 -> /film/456
        当前组件会被复用，导致的问题就是，组件不会销毁重建
        - 这种情况可以主动监听 $route 这个对象
        - 使用 beforeUpdate 这个守卫函数


    - beforeRouteLeave

            
- find 方法

```js
    var arr = [{ id: 1, name: '二愣子' },{ id: 2, name: '三傻子' }]
    arr.filter(item => {
        return item.id === 1;
    })
    // 返回的是一个新的数组 [ { id: 1, name: '二愣子' } ]

    arr.find(item => {
        return item.id === 1;
    })
    // 返回的是查询到的对象 { id: 1, name: '二愣子' }
```

- 全局解析守卫 

    - router.beforeResolve

# 完整的导航解析流程

1. 导航被触发（页面要做跳转了，/a -> /b）
2. 在失活的组件里调用离开守卫 （/a 调用 beforeRoteLeave）
3. 调用 全局的 beforeEach （前置）守卫
4. 在复用的组件里调用 beforeRouteUpdate 守卫 （根据情况 如果有复用的组件就会进来这一步）
5. 在路由配置中调用 beforeEnter
6. 解析异步路由组件
7. 在被激活的组件里调用 beforeRouteEnter
8. 调用全局的 beforeResolve 守卫
9. 导航被确认 （/a -> /b 就是 b 页面已经显示）
10. 调用全局的 afterEach （后置钩子）
11. 触发 DOM 更新
12. 用创建好的实例调用 beforeRouterEnter 守卫中传给 next 的回调函数

# 情况：

1. 比如说 /a -> /其他页面都可以 除了 /f 页面 可以在这个钩子函数中进行判断   beforeRouteLeave

2. 还可以 在每个页面跳转做一个日志信息    beforeRouteLeave

3. 如果 项目中某一个路由页面需要做登录校验，那么可以使用 beforeEnter

4. 如果 项目整个都需要做登录校验，那么可以使用 beforeEach

### next 使用
